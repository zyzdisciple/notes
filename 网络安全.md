# 计算机中的网络安全

<font face="微软雅黑">
主要体现在以下几个方面：

1. 机密性, 即发送的信息只有双方彼此能够解读,其他人以任何方式皆无法解读。

2. 报文完整性, 即接收方需要能够验证,当前接收到的数据是完整的,没有被经过篡改的。机密性与完整性是相互独立的两个属性。

3. 端点鉴别, 需要知道我收到的消息, 确确实实是来自于对方, 而不是恶意方伪装的。 

4. 运行性安全, 需要能够识别并阻拦恶意攻击。如 Dos攻击等, 其目的并非为了窃取信息,而是使得系统瘫痪, 无法运行。


## 机密性

首先来看机密性问题, 小明和小红之间发送的有效信息 不希望被第三方解读。 而实现这点的方式自然是, 加密, 加密,就需要相关的密码。

### 密码学

加密所要实现的根本目的是,将数据加密,除非拥有相关的秘钥,算法,才能够 也 必须能够 将数据恢复到 原始数据。

这里的原始数据被称作<font color="orange">明文</font>, 小明使用了<font color="orange">加密算法</font>加密其明文, 生成的文本为<font color="orange">密文</font>, 加密算法是公知的,而<font color="orange">秘钥</font>是私有的.

#### 对称秘钥体系

* 凯撒密码 是一种简单的加密算法。

    对于字母而言, 约定 用 当前字母的后 第K个字母加以替换, 即可生成对应的密文。

    如： a b c  k=2-> c d e

    只需要双方约定好共同的K, 即可进行加密解密。

* 更进一步 则是将 k=2 换成只有双方知道的算法, 如 k = index + 1, 即 k=3

    但缺点同样明显, 文本自身并不是没有特点的, 如小明和小红在沟通的时候常常会在开头加入对方的姓名, xiao hong,

    那么经过加密之后,变成了 zkcq jqpi, 则根据习惯来推算, 很容易就得出来 K = 2.


* 即使是它的改进算法：

    单码代替密码, 也难以规避掉这个问题。

    单码代替密码不再使用固定的K, 而是有 密码本 将 明文一一映射替换为 密文, 如  a->h b->k c->a, 双方都持有相应的密码本,即可完成加解密工作。

    但是依然是之前的 xiao hong 作为惯用语, 随着接收到的密文不断变大,变多,则能够逐步推算, 还原出对应的密码本。 完成解密工作。

* 多码代替密码

    这是对单码代替密码的一种改进, 对于明文中 文本 位置的不同 采用不同的 密码本进行匹配。 

    而秘钥呢？ 则是 多个密码本, 以及 位置 和 密码本之间的匹配关系。

对称加密在现代社会有两种宽泛的类型： 流密码, 块密码。

我们会观察到这样两个问题：

1. 在上面提到的几种简单的文本加密算法中, 仅仅能够对文本进行加密, 而我们在网络中传输 可不一定是文本,更大的可能性是流。 包括协议的首部, 数据报本身。我们所需要加密的对象不仅仅是文本, 而在网络中 自然更为合适的是对 数据流进行加密。 这并不意味着是 流密码。

2. 可匹配的可能性依然太少, 适用性不够强。 

而块密码, 正是前面几种简单密码的延伸。

我们将数据流进行拆分 3 6 64 128 等等 bit 为一个块, 然后对每一个块都进行加密。

注意到  对 3 bit块进行加密。 可能会映射到的结果有: 000 001 010 011 100 101 110 111 即 2^3 8中可能性。

而我们的输入同样有8种可能性, 因此会映射为 8! = 40320 种可能的结果。 即对每一种输入都找到其映射结果, 且与其他输入的结果不重复。

40320 种可能的结果, 对现代计算机来说破解起来实在是一件很轻易的事情。而为了防止被破解, 因此往往会采用更大的块 做为映射, 比如说 64位, 这样我们的可能结果就有 (2^64)! 想要破解无疑是一件很困难的事情。

不仅仅是破解起来很是困难,实现起来也是同样的困难,需要双方维护一个 2^64 的输入输出映射表, 如果需要改变映射表, 也需要双方都进行调整才可以。

而真实采用的方式,则是 使用函数来模拟 随机排列表, 一个简单的例子是：将 64bit拆分成 8 * 8 bit, 每次用一个 8bit的映射表,去置换第一个块, 将置换后的结果 与 剩余部分混合, 再循环置换 剩下的 bit块,经过n次循环以后, 就提供了一个64bit的块, 这种算法的秘钥是 8张排列表。

#### DES算法


> 参考链接：[数据加密算法--详解DES加密算法原理与实现](https://www.cnblogs.com/idreamo/p/9333753.html)

DES是一个分组加密算法,典型的DES以64位为分组对数据加密,加密和解密用的是同一个算法。

密钥长64位,密钥事实上是56位参与DES运算(第8、16、24、32、40、48、56、64位是校验位,使得每个密钥都有奇数个1),分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。

需要注意的地方是, 如果初始秘钥转换成 byte之后， 如果其前7位是相同的， 那么这两个秘钥所计算出来的数据就是相同的。 因为 8 16 等等 是不参与DES运算的。

> 参考链接：[JAVA DES 秘钥问题](https://blog.csdn.net/devotedwife/article/details/81837074) 

将初始秘钥 通过16轮的计算，转换， 生成16个子秘钥（子秘钥长度为48位）。

而后将明文数据:

首先按照固定的置换规则, 将原数据中的64bit 进行置换。 得到新的数据。

其中置换后的数据被分为两部分, L0、R0, L0是输出的左32位,R0是右32位

按照一定的规则 迭代置换 运用之前计算得到的 秘钥 加密, 16轮之后, 即得到所需的L16, R16。将两部分合并成一个分组,进行逆置换,逆置换正好是初始置换的逆运算,由此即得到密文输出。

其初始置换数据：

    58,50,42,34,26,18,10,2,

    60,52,44,36,28,20,12,4,

    62,54,46,38,30,22,14,6,

    64,56,48,40,32,24,16,8,

    57,49,41,33,25,17,9,1,

    59,51,43,35,27,19,11,3,

    61,53,45,37,29,21,13,5,

    63,55,47,39,31,23,15,7,

逆置换：

在初始置换规则表中, 观察会发现, 原本第一位的被挪到了第40位, 而在逆置换中， 需要将第四十位置换到第一位即可。

    40,8,48,16,56,24,64,32,

    39,7,47,15,55,23,63,31,

    38,6,46,14,54,22,62,30,

    37,5,45,13,53,21,61,29,

    36,4,44,12,52,20,60,28,

    35,3,43,11,51,19,59,27,

    34,2,42,10,50,18,58 26,

    33,1,41, 9,49,17,57,25,

正如上面所提到的：核心就是 置换，混合。 解密则是其逆过程。

#### 3DES

3DES（即Triple DES）是DES向AES过渡的加密算法，它使用2条56位的密钥对数据进行三次加密。是DES的一个更安全的变形。

设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，C代表密文

3DES加密过程为：C=Ek3(Dk2(Ek1(M)))

3DES解密过程为：M=Dk1(EK2(Dk3(C)))

即用 k1对数据加密 k2对加密过的数据解密 k3 对解密之后的数据再度加密.

K1、K2、K3决定了算法的安全性，若三个密钥互不相同，本质上就相当于用一个长为168位的密钥进行加密。多年来，它在对付强力攻击时是比较安全的。若数据对安全性要求不那么高，K1可以等于K3。在这种情况下，密钥的有效长度为112位。

不难发现 如果 k1=k2 的话， 与 DES算法是等价的， 这样有效的实现了与现有DES系统的向后兼容问题。因为当K1=K2时，三重DES的效果就和原来的DES一样，有助于逐渐推广三重DES。

#### AES

1. 运算速度快，在有反馈模式、无反馈模式的软硬件中，Rijndael都表现出非常好的性能。
2. 对内存的需求非常低,适合于受限环境。
3. Rijndael 是一个分组迭代密码， 分组长度和密钥长度设计灵活。
4. AES标准支持可变分组长度，分组长度可设定为32 比特的任意倍数，最小值为128 比特，最大值为256 比特。
5. AES的密钥长度比DES大， 它也可设定为32 比特的任意倍数，最小值为12 比特，最大值为256 比特，所以用穷举法是不可能破解的。
6. AES算法的设计策略是WTS。WTS 是针对差分分析和线性分析提出的，可对抗差分密码分析和线性密码分析。

而AES的优点， 正是 DES的缺点所在。

AES的具体实现，就不再这里提到了， 感兴趣的可以看参考链接。 在本篇中， 更关注 其核心思想是什么， 适用范围在何处，局限性又有哪些。

而 DES 3DES AES 其核心都是 分组， 置换， 加密混淆， 迭代。 这样一套处理体系。

用密码生成函数 替换了 原本固定的密码表。

> AES参考: [密码算法详解——AES](https://www.cnblogs.com/luop/p/4334160.html)

#### 密码块链接

需要注意到的是， 即使我们已经拥有了很强大的对称加密算法，但这就能够保证不被破解了吗？

假设我们认为暴力破解是不可行的， 那么在已知部分明文的情况下， 破解出密码并不是不可能的事情， 因为在加密算法中， 我们对于同一数据的加密结果总是相同的。而在 http传输中， HTTP/1.1 这必然是一个很常见的明文输入，我们匹配了所有的输入， 发现出现次数最多的 就可以代表其实 HTTP/1.1

考虑这样一种情况， 在两个人的通讯过程中，其中一个人的惯用词汇是 你猜， 几乎在100句聊天中， 就会出现80句以上的你猜。

那么我们只要抓取到 出现次数最多的密文， 必然就可以认定， 这个密文所对应的明文是 你猜。这样就能够大大减小我们破解密码的难度。

那么自然的， 就要求存在这样的方式， 使得对于相同的输入， 其加密后的密文 是不相同的。 即使小明说了一百句你猜。 对于其表现形式来说，其密文都是不同的。

因此，根本无法从杂乱无章的密文中， 判断出来究竟哪一句对应的明文是 小明的口头禅， 你猜。

这怎么实现呢？无非是在每次传输都附带一串数据，仅用于本数据的加密。 这依赖的是 异或 运算。

#### CBC

CBC模式的全称是Cipher Block Chaining模式（密文分组链接模式），之所以叫这个名字，是因为密文分组像链条一样相互连接在一起。

明文: Mi, 密文 Ci, 加密算法: Ks, 随机的k 比特数: Ri, 异或运算的结果: Ti 异或运算: a⊕b 

首先需要知道的是： 对于异或运算:

   1. a ⊕ a = 0
   2. a ⊕ b = b ⊕ a
   3. a ⊕b ⊕ c = a ⊕ (b ⊕ c) = (a ⊕ b) ⊕ c
   4. d = a ⊕ b ⊕ c 可以推出 a = d ⊕ b ⊕ c
   5. a ⊕ b ⊕ a = b

对于密文: Ci = Ks(Mi ⊕ Ri)， 即将Mi 与 Ri执行异或运算， 通过Ks加密算法对其进行加密， 最终得到密文 Ci。

对于解密: 根据第四条运算法则: d = a ⊕ b ⊕ c 可以推出 a = d ⊕ b ⊕ c

解密后的数据: Ti = Mi ⊕ Ri 则有 Mi = Ti ⊕ Ri, 即对密文进行解密 与 Ri做异或运算， 即可得到初始明文 Mi。

这就要求 我们对 每一个块(在对称加密算法中， 正是将数据分成一个又一个的块)， 都发送相应的Ri 用于处理数据。 Ri可以明文发送， 即使Ri被劫持到， 在没有秘钥的情况下， 依然是没有用的。

但这种方式同样会带来一个缺点，即对于每一个块， 我们都需要发送等长的Ri给对方(异或预算必然要求两者长度一样，才能进行异或运算。) 这样我们的数据长度就变为原来的两倍， 这实在是一笔不小的开销。

因此通常采用的方式是CBC, 其基本思想是， 仅随第一个报文发送一个随机值， 在之后的通讯中 通过计算获取 相应的编码。

因此，仅需要N+1个块， 就能够实现 对相同的明文，产生不同的密文。

### 公开秘钥加密

但在对称秘钥体系中， 会有这样一个问题， 如果一切依托于现实， 我们可以彼此约定一个只有双方知道的秘钥， 完成加密解密的相关工作。

但在网络通讯中， 这并不现实， TCP链接时时刻刻都在被销毁与创建中不断循环， 我们不可能在路由器两端使用固定的密码， 如果这样做的话 就意味着线路两端的路由器都要完成解密 然后加密的操作。 用自己的密码加密之后 发送给下一个节点。

我们也不可能将密码直接明文 在 通讯中直接传输， 那样的话， 和不加密又有什么区别呢？

这好像是个难题。

直到公开密码的出现:

是以这样的方式使用：

对于小B来说， 存在两个秘钥， 一个是 公知的 Kb+ 以及 只有自己存有的秘钥 Kb-, 当小A想要给小B发送消息时， 首先会取得 Kb+ 用一个公知的 加密算法 进行加密，得到密文 Kb+(m)， 而当小B接收到 Kb+(m) 时， 用一个公知的 解密算法 配以私钥 Kb- 进行解密， 最终使得 Kb-(Kb+(m)) = m。 这样需要解密密文， 就必须要两个秘钥才能够解密。

虽然这样会引入一个新的问题， 即 任何人都可以 截获 发送给小B的消息， 然后用自己准备好的明文， 通过 Kb+对明文加密， 发送给小B。

这就要求我们能够验证数据的来源方究竟是谁， 需要做端点鉴别， 即确确实实是小A自身发送给小B的消息， 而不是别人冒用名义 发送 分手吧 这样的悲惨消息。

### RSA算法

对于RSA算法， 个人比较感兴趣， 在这里描述的可能就会多一点。

对于任何数据流， 我们都不能忘记其本质 依然是 bit流， 而任何bit流 自然也能够用 唯一的 整数 去表示。

加密这个bit流 自然实际上就是加密这个 唯一数值。

在RSA算法中， 并没有将数据看成是 字符的集合， 而是数值， 这样我们就可以使用种种数学公式加以匹配。

RSA包含两个部分：

加密解密算法

两个秘钥， 公钥和私钥。

#### 秘钥的生成

1. 选择两个大素数， 这个值越大越好， 甚至已经超出了常规意义上的 大数值。 该值越大， 破解RSA算法越困难。 推荐公司使用时， p q 两个数的乘积 需要 为 1024bit数量级。
2. 计算 n=pq 和 z=(p - 1)(q - 1)
3. 选择小于n的一个数值 e， 且 e 和 z 互素。
4. 求解一个数d， 使得 ed - 1 可以被 z整除。换成数值表达则是:

   ed mod z = 1

5. 则公钥是 (n, e), 私钥是 (n, d); 

#### 加解密过程

1. 要求被加密的整数 m, m < n
2. 求解 c = (m ^ e) mod n, c即是加密后的密文
3. 求解 m = (c ^ d) mod n.

看上去实在是很简单的过程。

但是 我们需要注意到的是这样几个问题， p q 本身就是数百bit的值。
被加密的整数一般也都不会非常小。

需要计算  m ^ e   c ^ d， 这种种操作本身就是非常消耗计算力的过程。

更何况还需要求得大素数q p 本身。

#### 工作原理

将上述 加解密过程 合并起来看:

求解m时 即是求解： ((m^e) mod n)^d mod n

在模运算中有这样一个性质:

    a ^ b mod n = ((a mod n)^b) mod n 

则上述公式可以变为:

    m^ed mod n

因此现在就需要证明:

m ^ ed mod n = m

在数论中, 有：

如果 p q 是素数，且有 n = pq 和 z = (p -1) * (q - 1) 则 X^y mod n = X ^ (y mod z) mod n

因此上述被替换成:

m ^ (ed mod z) mod n => m ^ 1  mod n => (m 小于 n) m

同时如果注意到另一个特点:

如果加解密流程微调:

c = (m ^ d) mod n

m = (m ^ e) mod n

原因则是： m ^ ed mod n 等价于 m ^ de mod n

这个特性意味着什么呢？

意味着: 如果小B用自己的 私钥 加密数据，那么 小A 可以用 小B的公钥进行解密， 得到原始数据。 暂时这个功能好像还看不出来什么作用， 我们稍后再提。

#### RSA的大素数选择

这同样是一个难点. 如果不感兴趣可以跳过.

> 参考:
>
>[RSA周边——大素数是怎样生成的？](http://ju.outofmemory.cn/entry/93761)
>
>[数论部分第一节：素数与素性测试](http://www.matrix67.com/blog/archives/234)


RSA算法的核心正在于 找到两个大素数 p q 并且这个数值越大越好， 破解的难度就越高。

我们要将两个数相乘 很简单， 但是因式分解， 确定它是素数 又是一件很难的事情了。

惯用 也是最简单的方法， 正是采用试除法进行处理， 即从 2 开始逐个测试， 但目前而言， 我们需要的数值有数百位， 仅仅64位的long型 9223372036854775807 已经是这样大的一个数值， 更何况数百位？

##### 素性测试

1. 费马小定理:

    如果p是一个质数，而整数a不是p的倍数，则有a^(p-1)≡1(mod p)

    即: a的(p-1)次方除以p的余数恒等于1。

    费马小定理是判定一个数是否为素数的必要条件，并非充分条件，因为存在着一些伪素数满足费马小定理却不是素数.

    也就是说, 如果一个数是素数, 那么必然满足费马小定理. 换句话说， 如果存在一个数， 不满足费马小定理， 此时可以断定这个数必然不是素数.

2. Fermat 素性检验 
   
   则考虑a=2, 我们可以将选定的数用 a=2做检验, 如果判断不满足 费马小定理. 此时必然不是素数， 比起试除法要快很多。

    但遗憾的是，仅能通过不满足来检验不是素数, 如果满足我们也没办法确定他是素数.

    因此继续考虑a=3的情况，一个合数可能在a=2时通过了测试，但a=3时的计算结果却排除了素数的可能。于是，人们扩展了伪素数的定义，称满足 a^(n-1) mod n = 1 的合数n叫做以a为底的伪素数(pseudoprime to base a)。
 
    前10亿个自然数中同时以2和3为底的伪素数只有1272个，这个数目不到刚才的1/4。

    这告诉我们如果同时验证a=2和a=3两种情况，算法出错的概率降到了0.000025。

    容易想到，选择用来测试的a越多，算法越准确。通常我们的做法是，随机选择若干个小于待测数的正整数作为底数a进行若干次测试，只要有一次没有通过测试就可以判定这个数为合数。这就是Fermat素性测试。

    人们自然会想，如果考虑了所有小于n的底数a，出错的概率是否就可以降到0呢？遗憾的是，居然就有这样的合数，它可以通过所有a(前提是n与a互素)的测试。Carmichael第一个发现这样极端的伪素数，他把它们称作Carmichael数。前10亿个自然数中Carmichael数也有600个之多。这样高的出错率， 说明费马素性检验 依然不能够帮我们准确找到一个大素数. 依然需要加强算法.

3. Miller-Rabin素性测试

    基于下面的定理：
    
    如果p是素数，x是小于p的正整数，且x^2 mod p = 1，那么要么x=1，要么x=p-1。这是显然的，因为x^2 mod p = 1相当于p能整除x^2-1，也即p能整除(x+1)(x-1)。由于p是素数，那么只可能是x-1能被p整除(此时x=1)或x+1能被p整除(此时 x=p-1)。

    以 a==2，n==341为例，演示一下该测试是如何进行的。(2^340%341==1，但是341并不是一个质数)

    根据模运算的规则: a^b mod n = (a mod n)^b mod n

    2 ^ 340 mod 341 = (2^170 mod 341)^2 mod 341 == 1

    此时必然有: 2^170 mod 341 == 1 或 2^170 mod 341 = 340 而 2^170 mod 341 结果是等于 1的

    继续: 要求满足: 2^85 mod 341==1 或者  2^85 mod 341 == 340 但此时 两者都不满足, 所以341不是素数。

    所以测试的要点则是:  尽可能提取因子2， 把n-1表示成 d * 2 ^ r, 如果n是一个素数，那么或者a ^ d mod n=1，或者存在某个i使得a ^ (d * 2 ^ i) mod n = n - 1.

    但需要注意的是： Miller-Rabin 素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1373653。

    对 于大数的素性判断，目前Miller-Rabin算法应用最广泛。一般底数仍然是随机选取，但当待测数不太大时，选择测试底数就有一些技巧了。比如，如果 被测数小于4 759 123 141，那么只需要测试三个底数2, 7和61就足够了。当然，你测试的越多，正确的范围肯定也越大。如果你每次都用前7个素数(2, 3, 5, 7, 11, 13和17)进行测试，所有不超过341 550 071 728 320的数都是正确的。如果选用2, 3, 7, 61和24251作为底数，那么10^16内唯一的强伪素数为46 856 248 255 981。这样的一些结论使得Miller-Rabin算法在OI中非常实用。通常认为，Miller-Rabin素性测试的正确率可以令人接受，随机选取 k个底数进行测试算法的失误率大概为4^(-k)。

而 Miller-Rabin素性测试 也就是我们的终极法宝。

那么大素数是怎么生成的？

其实生成一个大素数非常简单，最直观的方法就是随机搜索，例如要生成一个100位的大素数，我们先随机生成一个数字序列，然后用Miller-Rabin素性测试对其进行测试即可，如果不是素数的话再随机生成一个，如此循环下去~

当然我们可以采用随机搜索法（每次生成一个完全不一样的随机数），也可以采用随机递增搜索法（生成一个随机数之后，每次对其加2）

生成一个n位十进制大素数的步骤如下：

1. 产生一个n位的随机数p，且最高位不能为0
2. 若最低位为偶数，则将它加1，保证该数为奇数以节省时间
3. 测试该数能否被10000以下的素数（共1228个）整除，这样可以快速排除许多合数，节省时间
3. 在2到p-1这间随机生成一个数a，以a为底对p进行Miller-Rabin素性测试，若不通过说明p为合数。若通过则再选取一个a对p进行测试。选取a时应该选取尽可能小的素数，以提高运算速度。大概进行5次Miller-Rabin素性测试后，精确性就比较高了
4. 若p每次测试都通过，则认为p是素数。否则p←p+2，再次对p进行测试

#### 会话秘钥

我们已经看到了，对于对称密码而言，密码本身的发送是一个问题，再者对待千千万万不同的用户， 我们需要不同的密码去应对每一个请求。

而RSA算法，加密起来确实无人可解， 但是运算太耗费时间， 需要的计算量是 对称秘钥算法的 成百上千倍。

那么，我们有没有一个比较好的处理办法能够解决这些问题呢？

当然是将两者结合起来使用了哇。

我们在一个会话刚刚开始时， 通过 RSA算法 加密 秘钥， 将秘钥发送给对方， 在之后的会话过程中， 使用对称秘钥进行会话即可。

## 完整性











</font>